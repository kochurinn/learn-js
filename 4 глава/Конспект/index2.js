// 4.1 ОБЪЕКТЫ

// Создавать объект можно двумя сбособами
let user = new Object(); // через "конструктор объекта"
let user = {};  // через "литерал объекта или литеральная нотация"

// получаем свойства объекта:
alert( user.name ); // John
alert( user.age ); // 30

delete user.age; // удаление свойства из объекта

let user = {
    name: "John",
    age: 30,
    "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
};

user["likes birds"] // обращение к свойству из нескольких слов
// так же в квадратных скобках может быть результат какого-то выражения




let fruit = 'apple'
let bag = {
    [fruit]: 5, // имя свойства будет взято из переменной fruit
};

let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};



function makeUser(name, age) {
    return {
      name, // сокращенная запись, если ключ:значение одинаковые
      age   
      // ...
    };
}



// Нет ограничен
let obj = {
    for: 1,
    let: 2,
    return: 3
};
alert( obj.for + obj.let + obj.return );  // 6

let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидал

// Проверка наличия свойства в объекте
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует

// Цикл по объекту

for (key in object) {
    // тело цикла выполняется для каждого свойства объекта
}

// Свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.


// 4.2 Копирование объектов и ссылки 

// Одно из фундаментальных отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

let a = {};
let b = a; // копирование по ссылке
alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true

let a = {};
let b = {}; // два независимых объекта
alert( a == b ); // false


// Как копировать объект?
// 1) через цикл
// 2) Object.assign()
// 3) Spread-оператор 

// Для глубокого копирования:
// 1) С помощью цикла, проверяя на объект внутри свойства
// 2) Рекурсия
// 3) метод structuredClone()


// 4.3 Сборка мусора

let user = {
    name: "John"
};

user = null; // сборщик мусора удалит данные об объекте, тк ссылка на него будет утеряна


let user = {
    name: "John"
};
let admin = user; // в таком случае на объект 2 ссылки

user = null; // тут уже сборщик памяти не сработает, тк 1 ссылка ещё имеется

// !!! Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым.

// Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.

// Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.

// Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.