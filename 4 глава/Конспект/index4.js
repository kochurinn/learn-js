// 4.8 Преобразование объектов в примитивы

// Правила преобразования:
// 1. Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
// 2. Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции. Например, объекты Date (которые будут рассмотрены в главе Дата и время) могут быть вычтены, и результатом date1 - date2 будет разница во времени между двумя датами.
// 3. Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.

// Хинты:
// "string"
// Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:
// // вывод
// alert(obj);
// // используем объект в качестве ключа
// anotherObj[obj] = 123;

// "number"
// Для преобразования объекта к числу, в случае математических операций:
// // явное преобразование
// let num = Number(obj);
// // математические (не считая бинарного плюса)
// let n = +obj; // унарный плюс
// let delta = date1 - date2;
// // сравнения больше/меньше
// let greater = user1 > user2;

// "default"
// Происходит редко, когда оператор «не уверен», какой тип ожидать.
// Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.
// Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".
// // бинарный плюс использует хинт "default"
// let total = obj1 + obj2;
// // obj == number использует хинт "default"
// if (user == 1) { ... };
// Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, так и с числами. Тем не менее, по историческим причинам, они используют хинт "number", а не "default".

// Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
// Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
// Иначе, если хинт равен "string"
// попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
// Иначе, если хинт равен "number" или "default"
// попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

obj[Symbol.toPrimitive] = function(hint) {
  // вот код для преобразования этого объекта в примитив
  // он должен вернуть примитивное значение
  // hint = чему-то из "string", "number", "default"
};

let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500

// Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:
// Для хинта "string": вызвать метод toString, а если он не существует или возвращает объект вместо примитивного значения, то valueOf (таким образом, toString имеет приоритет при строковом преобразовании).
// Для других хинтов: вызвать метод valueOf, а если он не существует или возвращает объект вместо примитивного значения, то toString (таким образом, valueOf имеет приоритет для математических операций).

// По умолчанию обычный объект имеет следующие методы toString и valueOf:
// Метод toString возвращает строку "[object Object]".
// Метод valueOf возвращает сам объект.

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500

// Довольно часто нам нужно единое «универсальное» место для обработки всех примитивных преобразований. В этом случае мы можем реализовать только toString:

let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
// В отсутствие Symbol.toPrimitive и valueOf, toString обработает все примитивные преобразования.



// 5.1 Методы примитивов

// Метод str.toUpperCase(), который возвращает строку в верхнем регистре.
// toFixed(n) округляет число до n знаков после запятой.

// Конструкторы String/Number/Boolean предназначены только для внутреннего пользования

// В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых местах последствия могут быть катастрофическими.
// Например:
alert( typeof 0 ); // "число"
alert( typeof new Number(0) ); // "object"!

// Объекты в if всегда дают true, так что в нижеприведённом примере будет показан alert:
let zero = new Number(0);
if (zero) {
  // zero возвращает "true", так как является объектом
  alert( "zero имеет «истинное» значение?!?" );
}

// С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
// К примеру, следующее вполне допустимо:
let num = Number("123"); // превращает строку в число


// 5.2 Числа

// Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:
let billion = 1000000000;

// Мы также можем использовать символ нижнего подчёркивания _ в качестве разделителя:
let billion = 1_000_000_000

let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
alert( 7.3e9 );  // 7.3 миллиарда (7,300,000,000)

// Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x, после которого указывается число.
// Например:
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

// Двоичные и восьмеричные числа используются не так часто, но они также поддерживаются: 0b для двоичных и 0o для восьмеричных:
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
alert( a == b ); // true, с двух сторон число 255

// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
// Например:
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

// base может варьироваться от 2 до 36 (по умолчанию 10).
// Часто используемые:
// base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.
// base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.
// base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления числа. Забавно, но можно использовать 36-разрядную систему счисления для получения короткого представления большого числового идентификатора. К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:

// Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
// Math.trunc (не поддерживается в Internet Explorer)
// Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

// Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 для хранения положения десятичной точки и один бит отведён на хранение знака.

// Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
alert( 1e500 ); // Infinity

// isNaN() - преобразует значение в число и проверяет является ли оно NaN 

// Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN уникально тем, что оно не является равным ничему другому, даже самому себе:
alert( NaN === NaN ); // false

// isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity

// Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:
alert( +"100px" ); // NaN

// Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке

// Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру

// Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
alert( parseInt('2n9c', 36) ); // 123456