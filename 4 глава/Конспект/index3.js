// 4.5 Конструктор, оператор "new"

// Когда функция вызывается как new User(...), происходит следующее:
// Создаётся новый пустой объект, и он присваивается this.
// Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
// Возвращается значение this.

// Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
// В случае обычного вызова функции new.target будет undefined. Если же она была вызвана при помощи new, new.target будет равен самой функции.

// При вызове return с объектом, вместо this вернётся объект.
// При вызове return с примитивным значением, оно проигнорируется.

// let user = new User; // <-- без скобок
// // то же, что и
// let user = new User();



// 4.6 Опциональная цепочка '?.'

// Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.


 
// 4.7 Тип данных Symbol

// «Символ» представляет собой уникальный идентификатор.

// Создаём новый символ - id
let id = Symbol();

// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

// Символы гарантированно уникальны
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2); // false

// Символы не преобразуются автоматически в строки
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string

// Если же мы действительно хотим вывести символ с помощью alert, то необходимо явно преобразовать его с помощью метода .toString(), вот так:
let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает

// Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:
let id = Symbol("id");
alert(id.description); // id

// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
// Вот так:
let id = Symbol("id");
let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};

// Свойства, чьи ключи – символы, не перебираются циклом for..in.
// Object.keys(user) также игнорирует символы.
// А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:

// Иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить доступ к символу "id", подразумевая именно одно и то же свойство.
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан
// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");
// проверяем -- это один и тот же символ
alert( id === idAgain ); // true

// Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id